**不是所有的特征都拥有特征对象，只有对象安全的特征才有，需要满足两个限制**：
- 方法不能返回Self类型（特征对象是动态分发，无法获知最初的类型了）
- 方法不能有任何泛型参数（猜测：rust会根据泛型函数的调用情况把所有的泛型函数具形化，但是如果是特征对象，那么特征对象去哪里找该具形的函数呢？）

**特征对象中的dyn如何理解？**
像rust中的泛型，这一类是静态分发的，编译时已经给泛型函数具形化了，但是特征对象却不是，其是动态分发的，dyn主要也是为了标识特征对象分发的动态性。

**&[str]类型中底层数据是如何被回收的？**  
比如let a="hello world"，那么hello world的生命周期结束之后就会被drop掉，a只是对hello world字符串的借用，如果在函数中传递，那么就需要生命周期规则，
编译器检查的是生命周期，为了不出现悬垂引用，要保证引用的生命周期比引用的数据要短。

**函数中生命周期理解**
```rust
fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}
```
T:'a说明t所引用的数据要比t活的久。

**理解类型生命周期**

代码如下：
```rust
struct Ref<'a, T: 'a> {
    r: &'a T
}
```
首先，生命周期指的是引用所关联的数据，而非引用自身。就上面结构体定义来说，r引用的数据至少要比a活的久，T:'a说明了T比a获得久，对于Ref对象来说，
因此这个约束表达的意思只有Ref对象中所引用的数据r比Ref对象活得久才有意义，可以先理解为T类型的数据对象比Ref中的字段r引用的对象活得久。

```rust
struct Manager<'a> {
    text: &'a str
}
```
这种场景可以理解为，Manager对象有一个生命周期a，manager中的对象至少比a活得要久才行。

**闭包的三个规则**

- 所有的闭包都自动实现了 FnOnce 特征，因此任何一个闭包都至少可以被调用一次
- 没有移出所捕获变量的所有权的闭包自动实现了 FnMut 特征
- 不需要对捕获变量进行改变的闭包自动实现了 Fn 特征

**NLL**

如下代码:
```rust
fn main() {
   let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // 新编译器中，r1,r2作用域在这里结束

    let r3 = &mut s;
    println!("{}", r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
  // 新编译器中，r3作用域在这里结束
```
可以看出来NLL是针对借用的，如果是对象本身其实还是按照最初的作用域来判定对象是否可用的。