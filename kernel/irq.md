# 中断

中断分为两部分，中断的上半部分和下半部分，中断发生后是在关中断的情况下执行中断处理程序，所以需要保证快速结束，因此把需要耗时的部分放到下半部分来做，
下半部分会在开中断下来做。

中断的上半部分只做有严格时限的工作，所以不能在此处sleep

## 总结
- 中断线可以共享，如果某一中断线发出了信号，那么该中断线上注册的所有中断处理函数都会被调用；
- 在中断处理程序处理中断时，默认情况下当前中断所标识的中断线会被关中断，其他的中断线正常；
- 在中断共享场景下，每个设备需要提供状态寄存器以便中断处理程序检查该中断是否是自己需要处理的；
- 当前内核的中断下半部分为三种类型：软中断，tasklet，任务队列。其中软中断和tasklet都执行在在中断上下文中，任务队列执行在进程上下文中，tasklet是通过软中断实现的，
  软中断一般在硬件中断返回后执行，而任务队列更像是每个处理器都绑定了一个线程，该线程有一个任务队列，当调度器调度到该线程时，该线程就把自己的任务拿出来逐个执行。

## 问题
- 中断上下文是在哪里分配的呢？比如中断栈在哪里呢？
- 处理器在收到中断信息后，会做保存寄存器的操作，具体怎么做的呢？
- 当中断处理程序处理完成后需要返回到进程上下文中，此时如果触发了抢占，那么怎么恢复被中断的程序呢？
- do_IRQ()函数怎么实现的，进入该函数是否会执行关中断？cpu是否会执行呢？
- disable_irq()函数会禁止指定的中断线，该函数会等待所有的中断处理程序都返回后才返回吗？
- in_interrupt()返回自己是否在中断上下文中，有什么用呢？
- 什么是进程上下文？什么是中断上下文？内核线程也运行在进程上下文中吗？